---
editor_options:
  chunk_output_type: console
---
# Library calls
```{r setup}
library(tidyverse)
library(rio)
library(data.table)
```

```{r functions}

```

# Reading in data
```{r importing data}
path <- "./markdown/data/"
keyword <- "bat_bachelor"

data <- list.files(
  path = path,
  pattern = keyword,
  full.names = T
  ) %>%
  map(import) %>% 
  data.table::rbindlist(
    fill = TRUE
  ) %>% 
  janitor::clean_names() %>% # make all names snake_case
  mutate(key_resp_trial_rt = ifelse(participant %in% 1:3, # added a 0.1 dead time after first three participants
                                    key_resp_trial_rt,
                                    key_resp_trial_rt + 0.1)) %>% 
  rename(
    "block" = loop_exp_this_n,
    "trial" = loop_trials_this_n,
    "response" = key_resp_trial_keys,
    "acc" = key_resp_trial_corr,
    "rt" = key_resp_trial_rt
  )
```

```{r checking condition mappings}
condition_table <- data %>% 
  count(map_condition, map_x_key, map_y_key) %>% 
  filter(!is.na(map_condition))
```

```{r extracting demo data}
demo_data <- "REPLACE ME CORRECTLY"
# No demo data was collected for first 7 participants (have in logbuch_ba.xlsx)
```

# Filtering out practice trials
```{r sort exp trials}
exp_data <- data %>% 
  group_by(participant) %>% # want to have map_x_key and map_y_key everywhere
  mutate(
    map_x_key = ifelse(map_x_key == "", NA, map_x_key),
    map_y_key = ifelse(map_y_key == "", NA, map_y_key)
  ) %>% 
  fill(map_x_key, .direction = "down") %>% 
  fill(map_y_key, .direction = "down") %>% 
  fill(map_condition, .direction = "down") %>% 
  ungroup() %>% 
  filter(is.na(loop_practice_this_n)) %>%  # Filter all practice trials
  janitor::remove_empty(which = "cols") # remove all columns that have just NA, could also remove all empty rows aswell

exp_data <- exp_data %>% # selecting important variables to front
  select(participant, block, trial, trial_type, acc, rt,
         response, map_condition,
         everything())
```

```{r adding decision variable}
dec_data <- exp_data %>% 
  mutate(decision_char = case_when(
    map_condition == 0 & response == "l" ~ "y",
    map_condition == 0 & response == "d" ~ "x",
    map_condition == 1 & response == "l" ~ "x",
    map_condition == 1 & response == "d" ~ "y",
    response == "None" ~ "none"
  )) %>% 
  mutate(decision = case_when(
    decision_char == "x" ~ 0,
    decision_char == "y" ~ 1,
    decision_char == "none" ~ -9
  ))
```

```{r just experimental data}
rt_data <- dec_data %>% 
  filter(!is.na(block)) # n.obs should be multiple of 3000
```

```{r coding error types}
# just coding errors in nogo trials as error
error_data <- rt_data %>% 
  group_by(participant, block) %>%  # consecutive errors have to be within a participant and block
  mutate(
    error_type = case_when(
      trial_type == "nogo" & acc == 0 & lag(trial_type) == "go" & lead(trial_type) =="go" ~ "error_single_lure",
      trial_type == "nogo" & acc == 0 & lag(trial_type) == "go" & lead(trial_type) == "nogo" ~ "error_double_lure_first",
      trial_type == "nogo" & acc == 0 & lag(trial_type) == "nogo" & lead(trial_type) == "go" ~ "error_double_lure_second",
    )
  ) %>% 
  mutate(
    error_code = case_when(
      lead(error_type) == "error_single_lure" ~ -1,
      error_type == "error_single_lure" ~ 0,
      lag(error_type) == "error_single_lure" ~ 1
    )
  ) %>% 
  ungroup()  %>% 
  group_by(participant, block) %>% 
  mutate(classic_pes_type = case_when(
    lag(trial_type, 2) == "go" & lag(trial_type) == "nogo" & trial_type == "go" & lag(acc) == 0 ~ "post_error",
    lag(trial_type, 2) == "go" & lag(trial_type) == "nogo" & trial_type == "go" & lag(acc) == 1 ~ "post_correct"
  )) %>% 
  ungroup()
```

```{r error id}
speed_data <- error_data %>% 
  group_by(participant, block) %>% 
  mutate(
    error_id = case_when(
      error_code == 0 ~ paste(participant, block, trial, sep = "_"),
      error_code == -1 ~ paste(participant, block, trial + 1, sep = "_"),
      error_code == 1 ~ paste(participant, block, trial - 1, sep = "_")
    )
  ) %>% 
  ungroup() %>% 
  group_by(participant) %>% 
  mutate(error_speed = case_when(
    error_code == 0 &
      rt >= median(rt, na.rm = TRUE) ~ "slow",
    error_code == 0 &
      rt < median(rt, na.rm = TRUE) ~ "fast"
  )) %>% 
  mutate(error_speed = case_when(
    error_id == lag(error_id) & error_id == lag(error_id, 2) ~ lag(error_speed),
    error_id == lead(error_id) & error_id == lead(error_id, 2) ~ lead(error_speed),
    error_id == error_id ~ error_speed
  )) %>% 
  ungroup()
```

```{r filtering participants}
# Filter out too fast responses aswell as 
speed_data %>% 
  filter(rt > 0.15) %>% 
  group_by(participant) %>% 
  summarize(mean_rt = mean(rt, na.rm = TRUE)) %>% 
  mutate(outlier = ifelse(
    mean_rt > mean(mean_rt) + 2.5*sd(mean_rt) |
      mean_rt < mean(mean_rt) - 2.5*sd(mean_rt),
    1,
    0
  )) %>% 
  count(outlier) # check if there are participant-level outliers

outlier_data <- speed_data %>% 
  filter(rt > 0.15 | is.na(rt)) %>% 
  group_by(participant) %>% # group by participant?
  # summarize( # sanity check
  #   mean_rt = mean(rt, na.rm = TRUE),
  #   sd_rt = sd(rt, na.rm = TRUE),
  #   ci_upper = mean_rt + 2.5*sd_rt,
  #   ci_lower = mean_rt - 2.5*sd_rt
  # )
  filter(
    (rt < mean(rt, na.rm = TRUE) + 2.5*sd(rt, na.rm = TRUE) &
      rt > mean(rt, na.rm = TRUE) - 2.5*sd(rt, na.rm = TRUE)) | is.na(rt)
  )
  
final_data <- outlier_data

```


```{r saving data}
export(final_data, "./markdown/data/analysis_data.Rdata")
```

