---
editor_options:
  chunk_output_type: console
---
# Library calls
```{r setup}
library(tidyverse)
library(rio)
library(data.table)

ggplot2::theme_set(theme_classic()) # setting default theme

# Diffusion model packages
library(brms)

# Rstan
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)

```

```{r functions}

```

```{r data}
data_robust <- rio::import("./markdown/data/diffusion_data_robust.Rdata")
data_classic <- rio::import("./markdown/data/diffusion_data_classic.rdata")
```

```{r set-formula}
formula <- bf( # TODO: Do I want an intercept here?, also move this to the end!
  rt | dec(decision) ~ 1 + rsi:error_factor + (1|p|id), 
    # random slopes just for rsi?
  bs ~ 1 + rsi:error_factor + (1|p|id),
    # because rsi and error_factor are known they can be used here
    # pre-error is not technically "known", but should affect bs and ndt nonetheless
  ndt ~ 1 + rsi:error_factor + (1|p|id),
  bias = 0.5
    # just want to estimate intercept for bias?
    # watch for prior/init function, can't just set bias to 0.5, only in acc-coding
)
```

```{r testing intercepts}
# TODO: Clean this up to show only why intercepts are suppressed
unique(model.matrix(~ 0 + rsi:error_factor, data_robust))
unique(model.matrix(~ 0 + rsi*error_factor, data_robust))
unique(model.matrix(~  rsi:error_factor, data_robust))

unique(model.matrix(~ 0 + rsi + error_factor + rsi:error_factor, data_robust))
unique(model.matrix(~ 1 + rsi + error_factor + rsi:error_factor, data_robust))
unique(model.matrix(~ 0 + rsi:error_factor, data_robust))
unique(model.matrix(~ 1 + rsi:error_factor, data_robust))
unique(model.matrix(~ 1 + rsi*error_factor, data_robust))

```

```{r formula-no-intercept}
formula_no_intercept <- bf(
  # No intercepts, bc this estimates parameters for each combination of
  # rsi and error_factor
  rt | dec(decision) ~ 0 + rsi:error_factor + (0 + rsi|p|id),
    # random slopes just for rsi for now. can do random slopes for error_factor later
    # TODO: Implement this! Model comparison?
  bs ~ 0 + rsi:error_factor + (0 + rsi|p|id),
    # because rsi and error_factor are known they can be used here
    # pre-error is not technically "known", but should affect bs and ndt nonetheless
  ndt ~ 0 + rsi:error_factor + (0 + rsi|p|id),
  bias = 0.5 # no reason for bias to vary
    # just want to estimate intercept for bias?
    # TODO: maybe estimate intercept for bias? 
)

auto_prior_no_int <- get_prior(# this just as sanity check
  formula = formula_no_intercept,
  data = data_robust,
  family = wiener(
    link_bs = "identity", #TODO: keep these identity links?, explain why
    link_ndt = "identity", 
    link_bias = "identity"
    )
)

prior_no_int <- c(
 # drift rate
 prior("lkj(1)", class = "cor"), # correlations between pars
 prior("normal(0,1)", class = "b"), # drift rate, population
  # prior research found drift rates between 0.1-0.3, this is weakly informative prior
 prior("normal(0, 0.3)", class = "sd"), # drift rate, group
  # TODO: Explain why this is used

 # boundary separation
 set_prior("normal(0, 2)", class = "b", dpar = "bs", lb = 0), 
  # bs restricted to > 0, lb = 0
 set_prior("normal(0, 0.3)", class = "sd", dpar =  "bs"), # group level

 # Non-decision time
 set_prior("normal(0.15, 0.1)", class = "b", dpar = "ndt", lb = 0),
 set_prior("normal(0, 0.3)", class = "sd", dpar =  "ndt"), # group level
 
 # Group-level priors
 set_prior("normal(0, 0.3)", class = "sd", group = "id")
)

make_stancode(formula_no_intercept, 
              family = wiener(link_bs = "identity", 
                              link_ndt = "identity",
                              link_bias = "identity"),
              data = data_robust, 
              prior = prior_no_int)

tmp_dat_no_int <- make_standata(
  formula_no_intercept, 
  family = wiener(
    link_bs = "identity", 
    link_ndt = "identity",
    link_bias = "identity"
    ),
  data = data_robust,
  prior = prior_no_int
  )

initfun_no_int <- function() {# all pars in stancode need init here
  list(
    b = rnorm(tmp_dat_no_int$K), # manual 4 pars? tmp_dat_no_int$K = 5
    b_bs = runif(tmp_dat_no_int$K_bs, 1, 2),
    b_ndt = rep(0.1, 4), # low ndt init, need 4 dims here?
    sd_1 = runif(tmp_dat_no_int$M_1, 0.5, 1),
    z_1 = matrix(rnorm(tmp_dat_no_int$M_1*tmp_dat_no_int$N_1, 0, 0.01),
                 tmp_dat_no_int$M_1, tmp_dat_no_int$N_1),
    L_1 = diag(tmp_dat_no_int$M_1)
  )
}

n_iter <- 3000
n_warmup <- 500
n_chains <- 4
n_cores <- 4
max_depth <- 15
adapt_delta <- 0.95


fit_wiener_no_int <- brm(
  formula_no_intercept, 
  data = data_robust,
  family = wiener(
    link_bs = "identity", 
    link_ndt = "identity",
    link_bias = "identity"
    ),
  prior = prior_no_int, 
  init = initfun_no_int,
  iter = n_iter, 
  warmup = n_warmup, 
  chains = 4,
  cores = n_cores, 
  control = list(max_treedepth = max_depth, adapt_delta = adapt_delta),
  refresh = 20,
  seed = 1234 # reproducibility
  )

save(fit_wiener_no_int, file = paste0("./markdown/models/brms_wiener_fit_", Sys.Date(), ".rda"),
     compress = "xz")
```


```{r get-prior}
auto_prior <- get_prior(
  formula = formula,
  data = data_robust,
  family = wiener(
    link_bs = "identity", #TODO: keep these identity links?
    link_ndt = "identity", 
    link_bias = "identity"
    )
)
```

```{r set-prior}
prior <- c(
 # drift rate
 prior("lkj(1)", class = "cor"), # correlations between pars
 prior("normal(0,1)", class = "b"), # drift rate, population
 prior("normal(0, 0.3)", class = "sd"), # drift rate, group
 set_prior("normal(0, 1)", class = "Intercept"), # intercept of drift rate (population)

 # # Bias
 # set_prior("beta(1.3, 1.3)", class = "Intercept", dpar = "bias", lb = 0, ub = 1), # Bias only intercept
 # # bias has bound 0, 1
 # boundary separation
 set_prior("normal(0, 2)", class = "b", dpar = "bs", lb = 0), 
  # bs restricted to > 0, lb = 0
 set_prior("normal(0, 0.3)", class = "sd", dpar =  "bs"), # group level

 # Non-decision time
 set_prior("normal(0.15, 0.1)", class = "b", dpar = "ndt", lb = 0),
 set_prior("normal(0, 0.3)", class = "sd", dpar =  "ndt"), # group level
 
 # Group-level priors
 set_prior("normal(0, 0.3)", class = "sd", group = "id") 
)
```

```{r stan-code-check}
# Check that all parameters listed
make_stancode(formula, 
              family = wiener(link_bs = "identity", 
                              link_ndt = "identity",
                              link_bias = "identity"),
              data = data_robust, 
              prior = prior)
```

```{r temp-starting-values}
tmp_dat <- make_standata(
  formula, 
  family = wiener(
    link_bs = "identity", 
    link_ndt = "identity",
    link_bias = "identity"
    ),
  data = data_robust,
  prior = prior
  )
```

```{r init-function}
initfun <- function() {# all pars in stancode need init here
  list(
    b = rnorm(tmp_dat$K, mean = 0, sd = 0.5), # manual 4 pars? tmp_dat$K = 5
    Intercept = runif(tmp_dat$K, 1, 2),
    b_bs = runif(tmp_dat$K_bs, 1, 2),
    Intercept_bs = runif(tmp_dat$K_bs, 1, 2),
    b_ndt = runif(tmp_dat$K_ndt, 0, 1),
    Intercept_ndt = array(0.05), # setting low initial ndt
    Intercept_bias = array(0.5), #TODO:  am I setting bias to 0.5 here? or just prior?
    sd_1 = runif(tmp_dat$M_1, 0.5, 1),
    z_1 = matrix(rnorm(tmp_dat$M_1*tmp_dat$N_1, 0, 0.01),
                 tmp_dat$M_1, tmp_dat$N_1),
    L_1 = diag(tmp_dat$M_1)#,
    # sd_2 = runif(tmp_dat$M_2, 0.5, 1),
    # z_2 = matrix(rnorm(tmp_dat$M_2*tmp_dat$N_2, 0, 0.01),
    #              tmp_dat$M_2, tmp_dat$N_2)
  )
}
```


```{r fitting model}

fit_wiener <- brm(
  formula, 
  data = data_robust,
  family = wiener(
    link_bs = "identity", 
    link_ndt = "identity",
    link_bias = "identity"
    ),
  prior = prior, 
  init = initfun,
  iter = n_iter, 
  warmup = n_warmup, 
  chains = 1,
  cores = n_cores, 
  # control = list(max_treedepth = max_depth, adapt_delta = adapt_delta),
  refresh = 20
  )
```

```{r pred}
fit_wiener <- rio::import("./markdown/models/brms_wiener_fit.rda")
n_pred <- 500
pred_wiener <- predict(fit_wiener, 
                       summary = FALSE, 
                       negative_rt = TRUE, 
                       ndraws = 500)
```

```{r save}
save(fit_wiener, file = "./markdown/models/brms_wiener_fit.rda", 
     compress = "xz")
save(pred_wiener, file = "./markdown/models/brms_wiener_predictions.rda", 
     compress = "xz")
```

